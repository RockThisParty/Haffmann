#include <iostream>
#include <vector>
#include <map>
#include <list>
#include <fstream>

using namespace std;

class Node
{
public:
	int a;
	char c;
	Node *left_child, *right_child;

	Node() 
	{ 
		left_child = right_child = NULL; 
	}

	Node(Node *L, Node *R)
	{
		left_child = L;
		right_child = R;
		a = L->a + R->a;
	}
};


struct MyCompare
{
	bool operator()(const Node* l, const Node* r) const 
	{ 
		return l->a < r->a; 
	}
};


vector<bool> code;
map<char, vector<bool> > table;

void BuildTable(Node *root)
{
	if (root->left_child != NULL)
	{
		code.push_back(0);
		BuildTable(root->left_child);
	}

	if (root->right_child != NULL)
	{
		code.push_back(1);
		BuildTable(root->right_child);
	}

	//if(root->c)
	if (root->left_child == NULL && root->right_child == NULL) 
		table[root->c] = code;

	code.pop_back();
}


int main(int argc, char *argv[])
{
	fstream f("1.txt");
	map<char, int> m;
	while (!f.eof())		//считаем частоты символов	
	{
		char c = f.get();
		m[c]++;
	}


	list<Node*> t;		//записываем начальные узлы в список list
	for (map<char, int>::iterator itr = m.begin(); itr != m.end(); ++itr)
	{
		Node *p = new Node;
		p->c = itr->first;
		p->a = itr->second;
		t.push_back(p);
	}


	
	while (t.size() != 1)		//создаем дерево
	{
		t.sort(MyCompare());

		Node *SonL = t.front();
		t.pop_front();
		Node *SonR = t.front();
		t.pop_front();

		Node *parent = new Node(SonL, SonR);
		t.push_back(parent);

	}

	Node *root = t.front();   	

	BuildTable(root);	// создаем пары 'символ-код':	
	f.clear();
	f.seekg(0);		// перемещаем указатель снова в начало файла
	while(!f.eof())
	{
		char c;
		f>>c;
		vector<bool> x=table[c];
		for(int n=0;n<x.size();++n)
		cout<<x[n];
	}
	
	
	// Выводим коды в файл output.txt
	
	
	ofstream g("output.bin");

	int count = 0; 
	char buf = 0;
	while (!f.eof())
	{
		char c = f.get();
		vector<bool> x = table[c];
		for (int n = 0; n < x.size(); n++)
		{
			buf = buf | x[n] << (7 - count);
			count++;
			if (count == 8) 
			{ 
				count = 0;   
				g << buf; 
				buf = 0; 
			}
		}
	}

	f.close();
	g.close();

	//считывание из файла output.txt и преобразование обратно
	ifstream F("output.bin");
	setlocale(LC_ALL, "Russian");
	Node *p = root;
	count = 0; char byte;
	byte = F.get();
	while (!F.eof())
	{
		bool b = byte & (1 << (7 - count));
		if (b)
		{
			p = p->right_child;
		}
		else
		{
			p = p->left_child;
		}
		//if(p->c)
		if (p->left_child == NULL && p->right_child == NULL) 
		{ 
			cout << p->c; 
			p = root; 
		}
		count++;
		if (count == 8) 
		{ 
			count = 0; 
			byte = F.get(); 
		}
	}
	F.close();
	return 0;
}